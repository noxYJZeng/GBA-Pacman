#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"

#include "analogSound.h"
#include "bgm.h"


/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

#include "images/start.h"
#include "images/sprite1.h"
#include "images/sprite2.h"
#include "images/blinky1.h"
#include "images/blinky2.h"
#include "images/play.h"
#include "images/pause.h"
#include "images/win.h"
#include "images/lose.h"



/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  PAUSE,
  WIN,
  LOSE,
};

u32 previousButtons;
u32 currentButtons;
enum gba_state state;

void startState(void);
void playState(void);
void pauseState(void);
void winState(void);

void updateScoreDisplay(void);
void resetGame(void);
void loseState(void);


extern Player player;
extern Target targets[MAX_TARGETS];
Color colors[8] =  {RED, ORANGE, YELLOW, GREEN, BLUE, CYAN, TEAL, MAGENTA};

// for bgm
int marioNoteIndex = 0;
int marioTimer = 0;

// for start state
int xPos = 0;
int spriteFrame = 0;
int frame = 0;
int xPos_blinky = 0;
int blinkyFrame = 0;
int spriteReset = 0;

//for play state
int playInitialized = 0;
int framePlay = 0;
int idleFrames = 0;
int lastScoreForIdle = -1;
int lastDisplayedScore = -1;

//for pause state
int pauseInitialized;

//for win state
int winInitialized;
// for lose state
int loseInitialized;

int totalTargetsEaten = 0;
int currentEnemySprite = 0;



int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3.
  
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  initSound();
  // Save current and previous state of button input.
  previousButtons = BUTTONS;
  currentButtons = BUTTONS;

  // Load initial application state
  state = START;
  drawFullScreenImageDMA(start);



  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
      resetGame(); 
      state = START;
      continue;
    }//reset the game
    
    switch (state) {
      case START:
        startState();
        break;
      case PLAY:
        playState();
        break;

      case PAUSE:
        pauseState();
        break;
      case WIN:
        winState();
        break;
      case LOSE:
        loseState();
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }


  return 0;
}

//Animates Pacman and Blinky across the screen. Plays background music. Transitions to PLAY state when the START button is pressed.
void startState(void) {
  waitForVBlank();

  drawString(70, 30, "PACMAN!", WHITE);

  undrawImageDMA(SPRITE_Y, xPos, SPRITE1_WIDTH, SPRITE1_HEIGHT, start);
  undrawImageDMA(BLINKY_Y, xPos_blinky, BLINKY1_WIDTH, BLINKY1_HEIGHT, start);

  if (!spriteReset) {
    xPos += SPRITE_SPEED;
  }

  if (xPos >= 30 && !spriteReset) {
    xPos_blinky = xPos - 30;
  }

  if (xPos > 240) {
    spriteReset = 1;
    xPos_blinky += SPRITE_SPEED;
  }

  if (spriteReset && xPos_blinky <= 240) {
    xPos = 0;
    xPos_blinky = xPos - 30;
    spriteReset = 0;
  }

  if (frame % SPRITE_ANIM_SPEED == 0) {
    spriteFrame = !spriteFrame;
    blinkyFrame = !blinkyFrame;
  }

  if (xPos >= 0 && xPos <= 240) {
    drawTransparentImageDMA(SPRITE_Y, xPos, SPRITE1_WIDTH, SPRITE1_HEIGHT,
                            spriteFrame == 0 ? sprite1 : sprite2);
  }

  if (xPos >= 30 && xPos_blinky >= 0 && xPos_blinky <= 240) {
    drawTransparentImageDMA(BLINKY_Y, xPos_blinky, BLINKY1_WIDTH, BLINKY1_HEIGHT,
                            blinkyFrame == 0 ? blinky1 : blinky2);
  }

  if (marioTimer == 0) {
    playNoteWithDuration(&marioTheme[marioNoteIndex], 2);
    marioTimer = marioTheme[marioNoteIndex].duration / (1000 / 60);
    marioNoteIndex = (marioNoteIndex + 1) % MARIO_THEME_LENGTH;
  } else {
      marioTimer--;
  }

  frame++;

  if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
    state = PLAY;
    marioNoteIndex = 0;
    marioTimer = 0;
  }
}


//Handles drawing, player movement, spawning and updating targets, score updating, win/lose conditions, and pause control.
void playState(void) {
  waitForVBlank();
  
  for (int i = 0; i < MAX_TARGETS; i++) {
    if (targets[i].active && targets[i].justSpawned &&
        targets[i].x >= 0 && targets[i].x < WIDTH) {
      undrawImageDMA(targets[i].y, targets[i].x,
                     targets[i].width, targets[i].height, play);
    }
  }


  undrawImageDMA(player.y, player.x, player.width, player.height, play);

  if (!playInitialized) {
    drawFullScreenImageDMA(play);
    playInitialized = 1;

    
  }
  updatePlayer();
  drawPlayer();
  
  updateTargets();
  drawTargets();
  updateScoreDisplay();
  
  
  if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
    pauseInitialized = 0;
    state = PAUSE;
  }

  if (idleFrames >= 600) {
    state = LOSE;
  }

  if (player.score >= 100) {
    state = WIN;
  }

  framePlay++;

}

//Redraws score only when changed. Also tracks idle time and changes color when near timeout.
void updateScoreDisplay(void) {

  if (player.score != lastScoreForIdle) {
      idleFrames = 0;
      lastScoreForIdle = player.score;
  }

  idleFrames++;

  if (player.score != lastDisplayedScore) {
      undrawImageDMA(2, 60, 36, 8, play);
      char buffer[10];
      sprintf(buffer, "%d", player.score);
      drawString(2, 60, buffer, YELLOW);
      lastDisplayedScore = player.score;
  }

  drawString(2, 2, "Score: ", YELLOW);
  drawString(2, 60 + 6 * 3, "/100", YELLOW);

  Color idleColor = RED;
  int idleSeconds = idleFrames / 60;
  undrawImageDMA(2, 136, 80, 8, play);
  
  if (idleSeconds >= 7 && idleSeconds < 10) {
    if ((framePlay / 15) % 2 == 0) {
        idleColor = WHITE;
    }
  }
  char idleBuf[20];
  sprintf(idleBuf, "Idle: %d/10s", idleSeconds);
  drawString(2, 140 + 6, idleBuf, idleColor);
}


//Displays pause message and score summary. Allows resuming the game or resetting to the title screen.
void pauseState(void) {
  waitForVBlank();

  if (!pauseInitialized) {
    drawFullScreenImageDMA(pause);
    pauseInitialized = 1;
  }

  if (player.score > lastDisplayedScore) {
    lastDisplayedScore = player.score;
  }

  drawString(20, 20, "PAUSED",BLACK);
  drawString(40, 20, "Press START to resume", WHITE);
  drawString(50, 20, "Press SELECT to reset", WHITE);

  char scoreBuf[30];
  sprintf(scoreBuf, "Current Score: %d", player.score);
  drawString(80, 20, scoreBuf, BLACK);

  char bestBuf[30];
  sprintf(bestBuf, "Best Score: %d", lastDisplayedScore);
  drawString(90, 20, bestBuf, BLACK);

  int idleSeconds = idleFrames / 60;
  char idleBuf[30];
  sprintf(idleBuf, "Idle Time: %ds", idleSeconds);
  drawString(100, 20, idleBuf, BLACK);

  if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
    playInitialized = 0;
    playInitialized = 0;
    lastDisplayedScore = -1;
    state = PLAY;

  }
}

//Displays a victory background and a celebratory message when the player scores 100 points.
void winState(void) {
  waitForVBlank();

  if (!winInitialized) {
    drawFullScreenImageDMA(win);
    winInitialized = 1;
  }

  char letters[8] = {'Y', 'O', 'U', ' ', 'W', 'I', 'N', '!'};
  int col = 72;
  int spacing = 12;
  for(int i = 0; i < 8; i++){
      drawChar(55, col + (i * spacing), letters[i], colors[i]);
  }

  drawString(110, 55, "Press SELECT to reset", WHITE);

}

//Displays a losing background and allows the player to reset the game.
void loseState(void) {
  waitForVBlank();
  if (!loseInitialized) {
    drawFullScreenImageDMA(lose);
    loseInitialized = 1;
  }
  drawString(110, 55, "Press SELECT to reset", WHITE);


}

//Prepares for a fresh game from the START screen, clearing targets, scores, timers, and animations.
void resetGame(void) {
  player.x = 30;
  player.y = 80;
  player.frame = 0;
  player.score = 0;

  frame = 0;
  framePlay = 0;
  idleFrames = 0;
  lastScoreForIdle = 0;
  lastDisplayedScore = -1;

  playInitialized = 0;
  pauseInitialized = 0;
  winInitialized = 0;
  loseInitialized = 0;

  for (int i = 0; i < MAX_TARGETS; i++) {
    targets[i].active = 0;
    targets[i].cooldown = 0;
    targets[i].justSpawned = 0;
  }

  drawFullScreenImageDMA(start);

  xPos = 0;
  spriteFrame = 0;
  xPos_blinky = 0;
  blinkyFrame = 0;
  spriteReset = 0;
}
